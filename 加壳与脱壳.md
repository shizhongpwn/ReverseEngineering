# 加壳与脱壳

## 加壳剖析

对于加壳程序，它需要存储被加壳程序导入函数表信息。

同时它的加载顺序也发生了变化：操作系统->脱壳存根->原始程序，而未加壳的程序为：操作系统->原始程序。

原始程序通常存在于加壳程序的一个或者多个附加节中。

为了解析原始程序的导入表函数，加壳程序中一般都会大量执行LoadLibrary,GetProcAdress两个函数。

同时其一般在加壳的最后采用跳转的方式开始执行到原始程序OEP处，尾部跳转指令一般为Jmp , call ,ret , 或者是函数NtContinue,ZwContinue。

### 注意

脱壳后的程序与原始程序仍然是不相同的，它依然包含脱壳存根，以及加壳程序添加的一些其他代码。脱壳后的程序包含一个被脱壳器重构的PE头部，并且与原始PE文件并不完全相同。

### 查找OEP

**自动化工具 **： OllyDbg 中的 OllyDump 插件，通过Section hop 调用Find OEP , 记得交叉使用step-over 和 step-into 方法，因为壳中一般都有类似于没有返回值的call函数来干扰分析，step-into单步每个call 更可能找到OEP,但是也可能误报。

**原理**：通常脱壳存根在一个节里面，而可执行程序被打包到另一个节里面，程序从一个节里面转移到另一个节里面的时候，Ollydbg可以探测到这种跳转，但是call指令通常用来执行其他节里面的代码，step-into单步每个call 更可能找到OEP,但是也可能误报，step-over是个解决这种误报的方法。

**手动查找**：通常尾部跳转是一条jmp指令或者ret指令之类的跳转指令，同时跳转指令后面一般都跟着一串无效字节指令，其是为了保证节的字节对齐。

### 常见壳对抗

**UPX**:   UPX -d   或者 OllyDump

**PECompact** : 其跟UPX类似，但是程序会产生异常，可以设置OllyDbg返回异常给程序。

还有一些乱七八糟的，总归就是先找对应工具，要不就手动脱。











