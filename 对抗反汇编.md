# 对抗反汇编

对抗反汇编利用的是反汇编器的错误假设和局限性来实现的。

## 线性反汇编

### 原理

其反汇编策略是遍历一个代码段，一次一条指令的线性反汇编，其利用已经反汇编的指令大小来决定下一个要被反汇编的字节。

### 缺陷

线性反汇编算法不能够区分数据和代码，容易被挫败，它还很容易将代码段的一些数据当做代码处理。	

### 例子

汇编指令call以0xE8开头，后接地址，但是如果代码段的16字节数据组成一个以0xE8结尾的开关表，那么当反汇编器碰到call指令机器码的时候，会把接下来的4字节数据当做操作数来对待。

### 解决方案

可以采用面向代码流的反汇编器进行反汇编，例如IDA pro.

## 面向代码流的反汇编

### 原理

其并不盲目的反汇编整个缓冲区，也不假设代码段中只包含指令而不包含数据，它会检查每一条指令，然后建立一个需要反汇编的地址列表。

其最大的特点在于会做一些假设和选择而不是盲目的从上到下的进行反汇编，但是这也导致反汇编一些简单的机器代码复杂化。

### 缺陷

在对于分析条件进行反汇编的时候，如果是正常情况下，无论是先反汇编false或者先反汇编true输出的代码没有任何区别，但是在人工编写的汇编代码与采用对抗反汇编编写的代码中，同一段代码块的两个分支经常会产生不同的反汇编结果。

**注意**：大多数面向代码流的反汇编器会首先处理条件跳转的false分支。

**注意**：大多数面向代码流的反汇编器会首先处理紧随call调用的字节，其次是call调用位置的字节。

## 对抗反汇编

### 运行时计算跳转地址(ctf-wiki实例)

demo:

~~~c
; ----------------------------------------------------------------------------
    call earth+1
Return:
                    ; x instructions or random bytes here               x byte(s)
earth:              ; earth = Return + x
    xor eax, eax    ; align disassembly, using single byte opcode       1 byte
    pop eax         ; start of function: get return address ( Return )  1 byte
                    ; y instructions or random bytes here               y byte(s)
    add eax, x+2+y+2+1+1+z ; x+y+z+6                                    2 bytes
    push eax        ;                                                   1 byte
    ret             ;                                                   1 byte
                    ; z instructions or random bytes here               z byte(s)
; Code:
                    ; !! Code Continues Here !!
; ----------------------------------------------------------------------------
~~~

程序通过`call+pop`来获取调用函数当时保存到栈上的返回地址, 其实就是调用函数前的`EIP`. 然后在函数返回处塞入垃圾数据. 但实际上在函数运行时已经将返回地址修改到了 Code 处. 因此`earth`函数返回会跳转到`Code`处继续运行，而不是`Return`处继续运行.